

import numpy as np
import rumdpy as rp

# Sim. params 
rho, temperature = 1.0, 1.5
alkane_length = 8 # Needs to be 'compatible' with initial FCC lattice, i.e. a multiplum of 4 (for now)
assert alkane_length > 3

angle0, k = 2.0, 500.0
#rbcoef=[15.5000,  20.3050, -21.9170, -5.1150,  43.8340, -52.6070]
rbcoef=[.0, 50.0, .0, .0, .0, .0]

# Generate configuration with a FCC lattice
configuration = rp.Configuration(D=3, type_names=['CA', 'CT'])
configuration.make_lattice(rp.unit_cells.FCC, cells=(8, 8, 8), rho=rho)
print(f'Number of {alkane_length}-alkanes: ', configuration.N // alkane_length)
print('Leftovers: ', configuration.N % alkane_length)
configuration['m'] = 1.0
terminal_carbons = list(range(0, configuration.N, alkane_length)) + list(range(alkane_length-1, configuration.N, alkane_length))
configuration.ptype[terminal_carbons] = 1
configuration['m'][terminal_carbons] = 1.1 # Do right units and values later
configuration.randomize_velocities(temperature=temperature)

# Setup topology 
configuration.topology.add_molecule_name('Alkane')
for n in range(0, configuration.N, alkane_length):
    for i in range(alkane_length-1):
        configuration.topology.bonds.append([n+i, n+i+1, 0])
  
    for i in range(alkane_length-2):
        configuration.topology.angles.append([n+i, n+i+1, n+i+2, 0])

    for i in range(alkane_length-3):
        configuration.topology.dihedrals.append([n+i, n+i+1, n+i+2, n+i+3, 0])

    configuration.topology.molecules['Alkane'].append(list(range(n, n + alkane_length)))


interactions = {} # Putting interactions in a dictionary to practice having them all in one object
                  # ... which culd be generated by eg. a forcefield. Simulations should accept a dict also

# Make bond interactions
bond_potential = rp.harmonic_bond_function
bond_params = [[1.0, 1000.], ]
interactions['bonds'] = rp.Bonds(bond_potential, bond_params, configuration.topology.bonds)

# Make angle interactions
angle_params = [[k, angle0],]
interactions['angles'] = rp.Angles(configuration.topology.angles, angle_params) 

# Make dihedral interactions
dihedral_params = [rbcoef, ]
interactions['dihedrals'] = rp.Dihedrals(configuration.topology.dihedrals, dihedral_params)

# Exlusion list
exclusions = interactions['dihedrals'].get_exclusions(configuration)

# Make pair potential
pair_func = rp.apply_shifted_force_cutoff(rp.LJ_12_6_sigma_epsilon)
sig = [[1.00, 0.80],
       [0.80, 0.88]]
eps = [[1.00, 1.50],
       [1.50, 0.50]]
cut = np.array(sig)*2.5
interactions['pair_pot'] = rp.PairPotential(pair_func, params=[sig, eps, cut], exclusions=exclusions, max_num_nbs=1000)

print(interactions)
print(repr(interactions))

# Make integrator
integrator = rp.integrators.NVT(temperature=temperature, tau=0.1, dt=0.002)

# Compute plan
compute_plan = rp.get_default_compute_plan(configuration)

# Setup runtime actions, i.e. actions performed during simulation of timeblocks
runtime_actions = [rp.ConfigurationSaver(), 
                   rp.ScalarSaver(), 
                   rp.MomentumReset(100)]

# Setup simulation
sim = rp.Simulation(configuration, list(interactions.values()), integrator, runtime_actions,
                    num_timeblocks=32, steps_per_timeblock=1024,
                    compute_plan=compute_plan, storage='memory')

angles_array, dihedrals_array = [], []
for block in sim.run_timeblocks():
    print(sim.status(per_particle=True))
    angles_array.append( interactions['angles'].get_angle(10, configuration) )
    dihedrals_array.append( interactions['dihedrals'].get_dihedral(10, configuration) )

print(sim.summary()) 

columns = ['U', 'W', 'K',] 
data = np.array(rp.extract_scalars(sim.output, columns, first_block=1)) 
temp = 2.0/3.0*np.mean(data[2])/configuration.N
Etot = data[0] + data[2]
Etot_mean = np.mean(Etot)/configuration.N
Etot_std = np.std(Etot)/configuration.N

print("Temp:  %.2f  Etot: %.2e (%.2e)" % (temp,  Etot_mean, Etot_std))
print("Angle: %.2f (%.2f) " % (np.mean(angles_array), np.std(angles_array)))
print("Dihedral: %.2f (%.2f) " % (np.mean(dihedrals_array), np.std(dihedrals_array)))

print('\nFinal molecular potential energies: ')
molecular_energies = np.array( [ np.sum(configuration['U'][atoms])
                      for atoms in configuration.topology.molecules['Alkane'] ])
print(molecular_energies[:15])

print(np.mean(molecular_energies), np.mean(configuration['U'])*alkane_length)
assert np.isclose(np.mean(molecular_energies), np.mean(configuration['U'])*alkane_length)